<examples>
  <example name="designing_microservice_architecture">
    <description>Creating a scalable microservice architecture for an e-commerce platform</description>
    <context>When tasked with designing the backend for a new e-commerce system with requirements for high availability and scalability</context>
    <steps>
      <step number="1">Research current best practices for microservice architectures using Context7</step>
      <step number="2">Investigate containerization and orchestration tools (Docker, Kubernetes)</step>
      <step number="3">Design service boundaries and data partitioning strategies</step>
      <step number="4">Create a numbered implementation plan with rationale for each service</step>
      <step number="5">Generate Mermaid diagrams showing service interactions</step>
      <step number="6">Review for potential bottlenecks and single points of failure</step>
      <step number="7">Refine the architecture based on identified issues</step>
    </steps>
    <mermaid_example>
      <![CDATA[
graph TD
  A[API Gateway] --> B[User Service]
  A --> C[Product Service]
  A --> D[Order Service]
  A --> E[Payment Service]
  B --> F[(User DB)]
  C --> G[(Product DB)]
  D --> H[(Order DB)]
  E --> I[External Payment API]
      ]]>
    </example>
  </example>

  <example name="implementing_real_time_features">
    <description>Adding real-time notifications and chat functionality to an existing application</description>
    <context>When enhancing an application to include live updates and messaging capabilities</context>
    <steps>
      <step number="1">Research real-time communication patterns (WebSockets, Server-Sent Events)</step>
      <step number="2">Evaluate libraries and frameworks for real-time features (Socket.io, Pusher)</step>
      <step number="3">Design data flow for real-time notifications and messages</step>
      <step number="4">Plan integration with existing authentication and user systems</step>
      <step number="5">Create a security review checklist for real-time features</step>
      <step number="6">Develop a phased implementation approach</step>
    </steps>
    <mermaid_example>
      <![CDATA[
sequenceDiagram
  participant C as Client
  participant S as Server
  participant DB as Database
  
  C->>S: Connect WebSocket
  S->>C: Connection Acknowledged
  S->>DB: Subscribe to Updates
  DB-->>S: Notify of Change
  S->>C: Push Real-time Update
      ]]>
    </example>
  </example>

  <example name="migrating_to_cloud_native">
    <description>Planning a migration from monolithic to cloud-native architecture</description>
    <context>When transitioning an existing monolithic application to a cloud-native platform like AWS or GCP</context>
    <steps>
      <step number="1">Research cloud-native design principles and best practices</step>
      <step number="2">Analyze the current monolithic application structure</step>
      <step number="3">Identify service boundaries for decomposition</step>
      <step number="4">Select appropriate cloud services (serverless, containers, managed DBs)</step>
      <step number="5">Design CI/CD pipelines for cloud deployment</step>
      <step number="6">Create a rollback strategy and risk assessment</step>
      <step number="7">Plan monitoring and observability solutions</step>
    </steps>
    <mermaid_example>
      <![CDATA[
graph LR
  A[Monolith] --> B[Service Decomposition]
  B --> C[Containerization]
  C --> D[Orchestration Platform]
  D --> E[Cloud Services Integration]
  E --> F[Monitoring & Observability]
      ]]>
    </example>
  </example>
</examples>